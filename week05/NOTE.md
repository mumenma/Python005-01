# 学习笔记
## 中间件
中间件包含缓存和消息队列

为什么需要增加缓存和消息队列
1、用户数量剧增，单凭数据库无法抗住并发压力
2、业务场景复杂需要解耦
3、业务场景丰富造成访问热点

## 缓存
### 分类
* 本地缓存  比如直接访问Django  主要是静态数据，或者一些配置文件配置数据
* 分布式缓存  比如Redis  一般是全局数据，或者多个模块之间共享的
### 缓存的同步方式
#### 应用和缓存之间的交互
* Cache Aside 方式： 应对简单的业务，需要考虑缓存和数据库
* Read 或是 Write Through：在后台服务和缓存之间添加一个网关，让后台服务认为后边是一个整体，不用考虑有没有缓存有没有数据库，不用管更新逻辑，应用程序不管了，需要开发对应的缓存和数据库策略
* Write Back：只去关缓存，不考虑数据库，但是缓存和数据库之间要有一个消息队列进行处理，但是有数据丢失的风险，对数据的一致性要求不高的场景
#### 缓存和数据库之间的交互
* 双写方式：应用程序通过多线程的方式往两边各写一遍，可能有数据不一致的情况，因为有一个方面可能写入失败，一般都是先写数据库，然后再写缓存，通常用分布式事务来处理，有两种方式，一种是如果其中一个写入失败了，直接都回退，反馈给用户失败，另外一种是定时的往缓存写入数据
* 消息队列方式：先写入消息队列，通过消息队列写入数据库，消息队列写入数据库成功之后才告知用户成功了，并更新缓存数据
* MySQL的binlog方式：最稳定的但是效率最差的方式，使用MySQL binlog 重放同步到缓存
## 缓存可能出现的问题
* 缓存穿透
  人为针对缓存没有的数据的请求，直接请求数据库，导致数据库压力暴增，使得数据库出现异常
  解决办法：
  方案1：做一个约定，如果数据库没有办法返回的或者返回的是个空值，那么把空值也进行缓存，一般设置为null，返回给缓存存储到缓存
  方案2：做一个过滤器，判断数据是不是在过滤器中，没有包含直接返回null，否则查询数据，但是有误杀的问题
* 缓存并发
  某一个key在缓存中刚好过期的时候，直接请求数据库，大量的请求这个key
  解决方案：使用互斥锁，使得只有一个线程去查询数据库，等更新好之后，别的请求直接请求到缓存上
* 缓存雪崩
  缓存设置不合理，或者启动缓存的时候，大量的key在同一时间过期
  解决方案：通过随机事件，让不同的key在不同的时间失效，另外一个方案是多级缓存
实际上都是大量的并发请求到数据库上产生的问题
## 安装Redis
### 官网
https://redis.io/
## 启动
redis-server ~/develop/redis.conf
### 特点
### 数据类型
* 字符串
  内部编码：int（8个字节长度）、embstr（小于39个字节）、raw（大于39个字节）
* 列表
  ```
  client.lpush('','') 左侧添加
  client.rpush('','') 右侧添加
  client.llen('') 获取列表的长度
  client.lpop('') 从左侧弹出数据，返回最左侧数据，Redis数据就把这个最左侧数据删除掉了
  client.rpop('') 从右侧弹出数据，返回最右侧数据，Redis数据就把这个最右侧数据删除掉了
  client.lrange('key',开始的位置0,结束的位置-1) 查看指定范围的列表数据
  ```
* 哈希
* 集合
  集合没有顺序
  
* 有序集合
### 不要贸然使用keys * 指令，会造成Redis短暂不响应
### Redis的重要机制
#### 生存时间
#### 主从复制
#### 哨兵

## 消息队列
brew install rabbitmq


使用rabbitmq之前开启插件
/usr/local/Cellar/rabbitmq/3.8.9_1/sbin/rabbitmq-plugins enable rabbitmq_management
启动
 /usr/local/Cellar/rabbitmq/3.8.9_1/sbin/rabbitmq-server restart
 http://localhost:15672  账号  guest 密码 guest
